/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
https://www.cgtrader.com/free-3d-models/aircraft/helicopter/boeing-sikorsky-rah-66a-comanche-00b8b4af-f529-456e-aa59-2a8ec3a1d2eb
by pjedvaj
*/

import React, { useEffect, useRef, useState } from "react";
import { useGLTF, useKeyboardControls } from "@react-three/drei";
import { CuboidCollider, RigidBody, interactionGroups, useRevoluteJoint, quat, vec3, euler, useRapier } from "@react-three/rapier";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from 'three';
import ChaseCamera from "../ChaseCamera";
import { useControls } from "leva";


export default function Heli(props) {
  const { nodes, materials } = useGLTF("./Models/Helicopter/heliMod7.glb");

  const heli = useRef()
  const rotorRef = useRef()
  const tailRotorRef = useRef()
  const tailRotorMesh = useRef()
  const fuselageRef = useRef()
  const fuselageMeshRef = useRef()

  const [ speed ] = useState((10.5))
  const testMaterial = new THREE.MeshBasicMaterial({color: 0xff0000})
  const glassMaterial = new THREE.MeshStandardMaterial({
    color: 0xfff,
    transparent: true,
    metalness: 0.9,
    roughness: 0.1,
    opacity: 0.1
  })
  
  const rotorJoint = useRevoluteJoint(rotorRef, fuselageRef, [
      [0, 0, 0],
      // Position of the joint in bodyB's local space
      [0, 0, 0],
      // Axis of the joint, expressed in the local-space of
      // the rigid-bodies it is attached to. Cannot be [0,0,0].
      [0, 1, 0]
  ])

 //controls
 const [ subscribeKeys, getKeys ] = useKeyboardControls()

 //physics
 const { world, setWorld, rapier } = useRapier()
  //  console.log(world.gravity)

  //camera controls
  const { cameraView } = useControls({
    cameraView: {
      value: {
        x: 10,
        y: 3,
        z: -20
      },
    
    }
  })

 useEffect(() => {
    if(fuselageRef.current){
      const position = vec3(fuselageRef.current.translation())
      const quaternion = quat(fuselageRef.current.rotation())
      const eulerRot = euler().setFromQuaternion(
        quat(fuselageRef.current.rotation())
      )

      fuselageRef.current.setTranslation(position, true)
      fuselageRef.current.setRotation(quaternion, true)
      fuselageRef.current.setAngvel({x: 0, y:2, z: 0}, true)
    }
 }, [])

 useFrame((state, delta) => {
  rotorJoint?.current?.configureMotorVelocity(10, 2)
  // fuselageRef?.current?.setAngularDamping(0.1)
  let position = new THREE.Vector3()
  let quaternion = new THREE.Quaternion()
  fuselageMeshRef.current.getWorldPosition(position)
  fuselageMeshRef.current.getWorldQuaternion(quaternion)
  console.log(quaternion)
  // console.log(position.y)
  if(position.y > 5){
    fuselageRef.current.setGravityScale(0, true)
    fuselageRef.current.resetForces(true)
    fuselageRef.current.resetTorques(true)
    fuselageRef.current.setAngularDamping(1)
    fuselageRef.current.setLinearDamping(1)
    fuselageRef.current.setEnabledRotations(false, false, false, true)

    if(quaternion.x < -0.1){
      fuselageRef.current.addForce({x: 0.01, y: 0, z: 0}, true)
    }
    if(quaternion.x > 0.1){
      fuselageRef.current.addForce({x: -0.01, y: 0, z: 0}, true)
    }
    if(quaternion.z < -0.1){
      fuselageRef.current.addForce({x: 0.0, y: 0, z: 0.01}, true)
    }
    if(quaternion.z > 0.1){
      fuselageRef.current.addForce({x: 0.0, y: 0, z: -0.01}, true)
    }
    // console.log(fuselageRef.current)
  }

  
  const time = state.clock.getElapsedTime()
  tailRotorMesh.current.rotation.x = time * 4.
  // console.log(fuselageMeshRef.current.position)
  const { forward, backward, leftward, rightward, upward, downward } = getKeys()
 
  if(upward){
    fuselageRef.current.applyImpulse({x: 0, y: 9.81 * 2. , z: 0}, true)  
  }

  if(downward){
    // fuselageRef.current.gravityScale = 0.1
    fuselageRef.current.applyImpulse({x: 0, y: -9.81 , z: 0}, true)
    console.log('down')
  }

  if(forward){
    // fuselageRef.current.applyImpulse({x:0, y:0, z: 10}, true)
    // heli.current.position.z += 0.1
    console.log('forward')
  }


 })

  const tailRotorFuselageJoint = useRevoluteJoint(fuselageRef, tailRotorRef, [
    [0, 0, 0],
    // Position of the joint in bodyB's local space
    [0, 0, 0],
    // Axis of the joint, expressed in the local-space of
    // the rigid-bodies it is attached to. Cannot be [0,0,0].
    [1, 0, 0]
  ])

  const testForce = () => {
    console.log('force applied')
    rotorRef.current.applyImpulseAtPoint({x: 0, y: 5., z: 0.}, {x: 0, y: 1.5, z: 10}, true)
    rotorRef.current.applyImpulseAtPoint({x: 0, y: 5., z: 0.}, {x: 0, y: 1.5, z: -10}, true)
    rotorRef.current.applyImpulseAtPoint({x: 0, y: 5., z: 0.}, {x: 10, y: 1.5, z: 10}, true)
    rotorRef.current.applyImpulseAtPoint({x: 0, y: 5., z: 0.}, {x: -10, y: 1.5, z: -10}, true)
    // rotorRef.current.applyImpulse({x:0, y:500, z:0}, true)
  }

  return (
    <group ref={heli} {...props} dispose={null}>
      <RigidBody type={"dyanmic"} colliders={false} ref={fuselageRef} collisionGroups={interactionGroups(0, [1])} gravityScale={1} >
        {/* <RoundCuboidCollider position={[0, 1.5, -1.75]} args={[0.5, 1., 5.85, 0.5]}/> */}
        <CuboidCollider position={[0, 1.5, -1.75]} args={[3., 1.5, 5.8]}/>
        <mesh
          ref={fuselageMeshRef}
          // onClick={testForce}
          castShadow
          receiveShadow
          geometry={nodes.Fuselage.geometry}
          material={materials.Paint}
          // material={testMaterial}
          position={[0, 0, -1.151]}
        />

        <mesh
          castShadow
          receiveShadow
          geometry={nodes.GlassDoor2.geometry}
          // material={materials.Glass}
          material={glassMaterial}
          position={[0, 0, -1.151]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.GlassDoor1.geometry}
          // material={materials.Glass}
          material={glassMaterial}
          position={[0, 0, -1.151]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Glass.geometry}
          // material={materials.Glass}
          material={glassMaterial}
          position={[0, 0, -1.151]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.WheelR.geometry}
          material={materials.Paint}
          position={[-1.05, 0.308, 1.341]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.RearWheel.geometry}
          material={materials.Paint}
          position={[0, 0.175, -5.809]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.WheelL.geometry}
          material={materials.Paint}
          position={[1.05, 0.308, 1.341]}
        />
        {/* <RigidBody type="dynamic" colliders="hull" ref={tailRotorRef}  collisionGroups={interactionGroups(0, [1])} gravityScale={0.0} position={[0.008, 1.361, -6.788]}> */}
        <mesh
          ref={tailRotorMesh}
          castShadow
          receiveShadow
          geometry={nodes.TailRotorMast.geometry}
          material={materials.Paint}
          // material={testMaterial}
          position={[0.008, 1.361, -6.788]}
        />
      {/* </RigidBody> */}
      </RigidBody>
      
      
      {/* <mesh
        castShadow
        receiveShadow
        geometry={nodes.Gun.geometry}
        material={materials.Paint}
        position={[0, 0, -1.15]}
      /> */}
      <RigidBody  type="dynamic" colliders="hull" ref={rotorRef} collisionGroups={interactionGroups(0, [1])} restitution={0.0} gravityScale={1}>
        <mesh
          // onClick={testForce}
          castShadow
          receiveShadow
          geometry={nodes.BladeBase.geometry}
          material={materials.Paint}
          position={[0.007, 3.172, 0.001]}
        />
      </RigidBody>
      
      <ChaseCamera object={fuselageMeshRef} offsetView={new THREE.Vector3(cameraView.x, cameraView.y, cameraView.z)}/>
    </group>
  );
}

useGLTF.preload("./Models/Helicopter/heliMod7.glb");

